{"version":3,"sources":["webpack:///../../src/util/mixins.ts","webpack:///../../src/util/colorUtils.ts","webpack:///../../src/util/rebuildFunctionalSlots.ts","webpack:///../../src/util/helpers.ts","webpack:///../../../src/util/color/transformSRGB.ts","webpack:///../../../src/util/color/transformCIELAB.ts","webpack:///../../src/util/dedupeModelListeners.ts","webpack:///../../src/util/console.ts","webpack:///../../src/util/mergeData.ts"],"names":["mixins","args","color","rgb","TypeError","c","char","parseInt","isNaN","hexColor","repeat","intToHex","colorToInt","children","slots","h","slot","el","name","functional","render","data","window","testListenerOpts","Object","get","e","console","last","path","obj","i","fallback","a","b","props","p","deepEqual","getNestedValue","property","item","getObjectValueByPath","Array","value","length","Node","index","getZIndex","tagsToReplace","str","tag","filtered","keys","key","unit","String","Number","keyCodes","enter","tab","delete","esc","space","up","down","left","right","end","home","del","backspace","insert","pageup","pagedown","iconName","iconPath","vm","camelizeRE","camelize","groupBy","groups","current","items","val","v","sortBy","stringCollator","Intl","sensitivity","usage","sortKey","sortA","sortB","sortDesc","customSorters","customResult","map","s","search","defaultFilter","split","k","scopedSlots","optional","min","max","Math","size","chunked","o","source","target","sourceProperty","targetProperty","isObject","mergeDeep","srgbForwardMatrix","srgbForwardTransform","C","srgbReverseMatrix","srgbReverseTransform","transform","matrix","xyz","r","g","delta","cielabForwardTransform","t","cielabReverseTransform","transformedY","Ln","lab","createMessage","_isVue","$parent","$options","generateComponentTrace","newMessage","message","consoleError","original","consoleWarn","classifyRE","classify","formatComponentName","options","file","match","includeFile","tree","currentRecursiveSequence","pattern","styleList","styleProp","parseStyle","styleMap","style","mergeTarget","arguments","prop","j","listeners"],"mappings":"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","file":"js/chunk-vendors~dde583c9.65f36cea.js","sourcesContent":["/* eslint-disable max-len, import/export, no-use-before-define */\nimport Vue, { VueConstructor } from 'vue'\n\nexport default function mixins<T extends VueConstructor[]> (...args: T): ExtractVue<T> extends infer V ? V extends Vue ? VueConstructor<V> : never : never\nexport default function mixins<T extends Vue> (...args: VueConstructor[]): VueConstructor<T>\nexport default function mixins (...args: VueConstructor[]): VueConstructor {\n  return Vue.extend({ mixins: args })\n}\n\n/**\n * Returns the instance type from a VueConstructor\n * Useful for adding types when using mixins().extend()\n */\nexport type ExtractVue<T extends VueConstructor | VueConstructor[]> = T extends (infer U)[]\n  ? UnionToIntersection<\n    U extends VueConstructor<infer V> ? V : never\n  >\n  : T extends VueConstructor<infer V> ? V : never\n\ntype UnionToIntersection<U> =\n  (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never\n","import { consoleWarn } from './console'\nimport { chunk, padEnd } from './helpers'\nimport { toXYZ } from './color/transformSRGB'\n\nexport type ColorInt = number\nexport type XYZ = [number, number, number]\nexport type LAB = [number, number, number]\nexport type HSV = { h: number, s: number, v: number }\nexport type HSVA = HSV & { a: number }\nexport type RGB = { r: number, g: number, b: number }\nexport type RGBA = RGB & { a: number }\nexport type HSL = { h: number, s: number, l: number }\nexport type HSLA = HSL & { a: number }\nexport type Hex = string\nexport type Hexa = string\nexport type Color = string | number | {}\n\nexport function colorToInt (color: Color): ColorInt {\n  let rgb\n\n  if (typeof color === 'number') {\n    rgb = color\n  } else if (typeof color === 'string') {\n    let c = color[0] === '#' ? color.substring(1) : color\n    if (c.length === 3) {\n      c = c.split('').map(char => char + char).join('')\n    }\n    if (c.length !== 6) {\n      consoleWarn(`'${color}' is not a valid rgb color`)\n    }\n    rgb = parseInt(c, 16)\n  } else {\n    throw new TypeError(`Colors can only be numbers or strings, recieved ${color == null ? color : color.constructor.name} instead`)\n  }\n\n  if (rgb < 0) {\n    consoleWarn(`Colors cannot be negative: '${color}'`)\n    rgb = 0\n  } else if (rgb > 0xffffff || isNaN(rgb)) {\n    consoleWarn(`'${color}' is not a valid rgb color`)\n    rgb = 0xffffff\n  }\n\n  return rgb\n}\n\nexport function intToHex (color: ColorInt): string {\n  let hexColor: string = color.toString(16)\n\n  if (hexColor.length < 6) hexColor = '0'.repeat(6 - hexColor.length) + hexColor\n\n  return '#' + hexColor\n}\n\nexport function colorToHex (color: Color): string {\n  return intToHex(colorToInt(color))\n}\n\n/**\n * Converts HSVA to RGBA. Based on formula from https://en.wikipedia.org/wiki/HSL_and_HSV\n *\n * @param color HSVA color as an array [0-360, 0-1, 0-1, 0-1]\n */\nexport function HSVAtoRGBA (hsva: HSVA): RGBA {\n  const { h, s, v, a } = hsva\n  const f = (n: number) => {\n    const k = (n + (h / 60)) % 6\n    return v - v * s * Math.max(Math.min(k, 4 - k, 1), 0)\n  }\n\n  const rgb = [f(5), f(3), f(1)].map(v => Math.round(v * 255))\n\n  return { r: rgb[0], g: rgb[1], b: rgb[2], a }\n}\n\n/**\n * Converts RGBA to HSVA. Based on formula from https://en.wikipedia.org/wiki/HSL_and_HSV\n *\n * @param color RGBA color as an array [0-255, 0-255, 0-255, 0-1]\n */\nexport function RGBAtoHSVA (rgba: RGBA): HSVA {\n  if (!rgba) return { h: 0, s: 1, v: 1, a: 1 }\n\n  const r = rgba.r / 255\n  const g = rgba.g / 255\n  const b = rgba.b / 255\n  const max = Math.max(r, g, b)\n  const min = Math.min(r, g, b)\n\n  let h = 0\n\n  if (max !== min) {\n    if (max === r) {\n      h = 60 * (0 + ((g - b) / (max - min)))\n    } else if (max === g) {\n      h = 60 * (2 + ((b - r) / (max - min)))\n    } else if (max === b) {\n      h = 60 * (4 + ((r - g) / (max - min)))\n    }\n  }\n\n  if (h < 0) h = h + 360\n\n  const s = max === 0 ? 0 : (max - min) / max\n  const hsv = [h, s, max]\n\n  return { h: hsv[0], s: hsv[1], v: hsv[2], a: rgba.a }\n}\n\nexport function HSVAtoHSLA (hsva: HSVA): HSLA {\n  const { h, s, v, a } = hsva\n\n  const l = v - (v * s / 2)\n\n  const sprime = l === 1 || l === 0 ? 0 : (v - l) / Math.min(l, 1 - l)\n\n  return { h, s: sprime, l, a }\n}\n\nexport function HSLAtoHSVA (hsl: HSLA): HSVA {\n  const { h, s, l, a } = hsl\n\n  const v = l + s * Math.min(l, 1 - l)\n\n  const sprime = v === 0 ? 0 : 2 - (2 * l / v)\n\n  return { h, s: sprime, v, a }\n}\n\nexport function RGBAtoCSS (rgba: RGBA): string {\n  return `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`\n}\n\nexport function RGBtoCSS (rgba: RGBA): string {\n  return RGBAtoCSS({ ...rgba, a: 1 })\n}\n\nexport function RGBAtoHex (rgba: RGBA): Hex {\n  const toHex = (v: number) => {\n    const h = Math.round(v).toString(16)\n    return ('00'.substr(0, 2 - h.length) + h).toUpperCase()\n  }\n\n  return `#${[\n    toHex(rgba.r),\n    toHex(rgba.g),\n    toHex(rgba.b),\n    toHex(Math.round(rgba.a * 255)),\n  ].join('')}`\n}\n\nexport function HexToRGBA (hex: Hex): RGBA {\n  const rgba = chunk(hex.slice(1), 2).map((c: string) => parseInt(c, 16))\n\n  return {\n    r: rgba[0],\n    g: rgba[1],\n    b: rgba[2],\n    a: Math.round((rgba[3] / 255) * 100) / 100,\n  }\n}\n\nexport function HexToHSVA (hex: Hex): HSVA {\n  const rgb = HexToRGBA(hex)\n  return RGBAtoHSVA(rgb)\n}\n\nexport function HSVAtoHex (hsva: HSVA): Hex {\n  return RGBAtoHex(HSVAtoRGBA(hsva))\n}\n\nexport function parseHex (hex: string): Hex {\n  if (hex.startsWith('#')) {\n    hex = hex.slice(1)\n  }\n\n  hex = hex.replace(/([^0-9a-f])/gi, 'F')\n\n  if (hex.length === 3) {\n    hex = hex.split('').map(x => x + x).join('')\n  }\n\n  if (hex.length === 6) {\n    hex = padEnd(hex, 8, 'F')\n  } else {\n    hex = padEnd(padEnd(hex, 6), 8, 'F')\n  }\n\n  return `#${hex}`.toUpperCase().substr(0, 9)\n}\n\nexport function RGBtoInt (rgba: RGBA): ColorInt {\n  return (rgba.r << 16) + (rgba.g << 8) + rgba.b\n}\n\n/**\n * Returns the contrast ratio (1-21) between two colors.\n *\n * @param c1 First color\n * @param c2 Second color\n */\nexport function contrastRatio (c1: RGBA, c2: RGBA): number {\n  const [, y1] = toXYZ(RGBtoInt(c1))\n  const [, y2] = toXYZ(RGBtoInt(c2))\n\n  return (Math.max(y1, y2) + 0.05) / (Math.min(y1, y2) + 0.05)\n}\n","import { CreateElement, VNode } from 'vue'\n\nexport default function rebuildFunctionalSlots (slots: { [key: string]: VNode[] | undefined }, h: CreateElement) {\n  const children: VNode[] = []\n\n  for (const slot in slots) {\n    if (slots.hasOwnProperty(slot)) {\n      children.push(h('template', { slot }, slots[slot]))\n    }\n  }\n\n  return children\n}\n","import Vue from 'vue'\nimport { VNode, VNodeDirective } from 'vue/types'\nimport { VuetifyIcon } from 'vuetify/types/services/icons'\nimport { DataTableCompareFunction, SelectItemKey, ItemGroup } from 'types'\n\nexport function createSimpleFunctional (\n  c: string,\n  el = 'div',\n  name?: string\n) {\n  return Vue.extend({\n    name: name || c.replace(/__/g, '-'),\n\n    functional: true,\n\n    render (h, { data, children }): VNode {\n      data.staticClass = (`${c} ${data.staticClass || ''}`).trim()\n\n      return h(el, data, children)\n    },\n  })\n}\n\nexport type BindingConfig = Pick<VNodeDirective, 'arg' | 'modifiers' | 'value'>\nexport function directiveConfig (binding: BindingConfig, defaults = {}): VNodeDirective {\n  return {\n    ...defaults,\n    ...binding.modifiers,\n    value: binding.arg,\n    ...(binding.value || {}),\n  }\n}\n\nexport function addOnceEventListener (\n  el: EventTarget,\n  eventName: string,\n  cb: (event: Event) => void,\n  options: boolean | AddEventListenerOptions = false\n): void {\n  var once = (event: Event) => {\n    cb(event)\n    el.removeEventListener(eventName, once, options)\n  }\n\n  el.addEventListener(eventName, once, options)\n}\n\nlet passiveSupported = false\ntry {\n  if (typeof window !== 'undefined') {\n    const testListenerOpts = Object.defineProperty({}, 'passive', {\n      get: () => {\n        passiveSupported = true\n      },\n    })\n\n    window.addEventListener('testListener', testListenerOpts, testListenerOpts)\n    window.removeEventListener('testListener', testListenerOpts, testListenerOpts)\n  }\n} catch (e) { console.warn(e) }\nexport { passiveSupported }\n\nexport function addPassiveEventListener (\n  el: EventTarget,\n  event: string,\n  cb: EventHandlerNonNull | (() => void),\n  options: {}\n): void {\n  el.addEventListener(event, cb, passiveSupported ? options : false)\n}\n\nexport function getNestedValue (obj: any, path: (string | number)[], fallback?: any): any {\n  const last = path.length - 1\n\n  if (last < 0) return obj === undefined ? fallback : obj\n\n  for (let i = 0; i < last; i++) {\n    if (obj == null) {\n      return fallback\n    }\n    obj = obj[path[i]]\n  }\n\n  if (obj == null) return fallback\n\n  return obj[path[last]] === undefined ? fallback : obj[path[last]]\n}\n\nexport function deepEqual (a: any, b: any): boolean {\n  if (a === b) return true\n\n  if (a instanceof Date && b instanceof Date) {\n    // If the values are Date, they were convert to timestamp with getTime and compare it\n    if (a.getTime() !== b.getTime()) return false\n  }\n\n  if (a !== Object(a) || b !== Object(b)) {\n    // If the values aren't objects, they were already checked for equality\n    return false\n  }\n\n  const props = Object.keys(a)\n\n  if (props.length !== Object.keys(b).length) {\n    // Different number of props, don't bother to check\n    return false\n  }\n\n  return props.every(p => deepEqual(a[p], b[p]))\n}\n\nexport function getObjectValueByPath (obj: any, path: string, fallback?: any): any {\n  // credit: http://stackoverflow.com/questions/6491463/accessing-nested-javascript-objects-with-string-key#comment55278413_6491621\n  if (obj == null || !path || typeof path !== 'string') return fallback\n  if (obj[path] !== undefined) return obj[path]\n  path = path.replace(/\\[(\\w+)\\]/g, '.$1') // convert indexes to properties\n  path = path.replace(/^\\./, '') // strip a leading dot\n  return getNestedValue(obj, path.split('.'), fallback)\n}\n\nexport function getPropertyFromItem (\n  item: object,\n  property: SelectItemKey,\n  fallback?: any\n): any {\n  if (property == null) return item === undefined ? fallback : item\n\n  if (item !== Object(item)) return fallback === undefined ? item : fallback\n\n  if (typeof property === 'string') return getObjectValueByPath(item, property, fallback)\n\n  if (Array.isArray(property)) return getNestedValue(item, property, fallback)\n\n  if (typeof property !== 'function') return fallback\n\n  const value = property(item, fallback)\n\n  return typeof value === 'undefined' ? fallback : value\n}\n\nexport function createRange (length: number): number[] {\n  return Array.from({ length }, (v, k) => k)\n}\n\nexport function getZIndex (el?: Element | null): number {\n  if (!el || el.nodeType !== Node.ELEMENT_NODE) return 0\n\n  const index = +window.getComputedStyle(el).getPropertyValue('z-index')\n\n  if (!index) return getZIndex(el.parentNode as Element)\n  return index\n}\n\nconst tagsToReplace = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n} as any\n\nexport function escapeHTML (str: string): string {\n  return str.replace(/[&<>]/g, tag => tagsToReplace[tag] || tag)\n}\n\nexport function filterObjectOnKeys<T, K extends keyof T> (obj: T, keys: K[]): { [N in K]: T[N] } {\n  const filtered = {} as { [N in K]: T[N] }\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i]\n    if (typeof obj[key] !== 'undefined') {\n      filtered[key] = obj[key]\n    }\n  }\n\n  return filtered\n}\n\nexport function convertToUnit (str: string | number | null | undefined, unit = 'px'): string | undefined {\n  if (str == null || str === '') {\n    return undefined\n  } else if (isNaN(+str!)) {\n    return String(str)\n  } else {\n    return `${Number(str)}${unit}`\n  }\n}\n\nexport function kebabCase (str: string): string {\n  return (str || '').replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()\n}\n\nexport function isObject (obj: any): obj is object {\n  return obj !== null && typeof obj === 'object'\n}\n\n// KeyboardEvent.keyCode aliases\nexport const keyCodes = Object.freeze({\n  enter: 13,\n  tab: 9,\n  delete: 46,\n  esc: 27,\n  space: 32,\n  up: 38,\n  down: 40,\n  left: 37,\n  right: 39,\n  end: 35,\n  home: 36,\n  del: 46,\n  backspace: 8,\n  insert: 45,\n  pageup: 33,\n  pagedown: 34,\n})\n\n// This remaps internal names like '$cancel' or '$vuetify.icons.cancel'\n// to the current name or component for that icon.\nexport function remapInternalIcon (vm: Vue, iconName: string): VuetifyIcon {\n  if (!iconName.startsWith('$')) {\n    return iconName\n  }\n\n  // Get the target icon name\n  const iconPath = `$vuetify.icons.values.${iconName.split('$').pop()!.split('.').pop()}`\n\n  // Now look up icon indirection name,\n  // e.g. '$vuetify.icons.values.cancel'\n  return getObjectValueByPath(vm, iconPath, iconName)\n}\n\nexport function keys<O> (o: O) {\n  return Object.keys(o) as (keyof O)[]\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nconst camelizeRE = /-(\\w)/g\nexport const camelize = (str: string): string => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : '')\n}\n\n/**\n * Returns the set difference of B and A, i.e. the set of elements in B but not in A\n */\nexport function arrayDiff (a: any[], b: any[]): any[] {\n  const diff: any[] = []\n  for (let i = 0; i < b.length; i++) {\n    if (a.indexOf(b[i]) < 0) diff.push(b[i])\n  }\n  return diff\n}\n\n/**\n * Makes the first character of a string uppercase\n */\nexport function upperFirst (str: string): string {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n}\n\nexport function groupItems<T extends any = any> (\n  items: T[],\n  groupBy: string[],\n  groupDesc: boolean[]\n): ItemGroup<T>[] {\n  const key = groupBy[0]\n  const groups: ItemGroup<T>[] = []\n  let current = null\n  for (var i = 0; i < items.length; i++) {\n    const item = items[i]\n    const val = getObjectValueByPath(item, key)\n    if (current !== val) {\n      current = val\n      groups.push({\n        name: val,\n        items: [],\n      })\n    }\n    groups[groups.length - 1].items.push(item)\n  }\n  return groups\n}\n\nexport function wrapInArray<T> (v: T | T[] | null | undefined): T[] { return v != null ? Array.isArray(v) ? v : [v] : [] }\n\nexport function sortItems<T extends any = any> (\n  items: T[],\n  sortBy: string[],\n  sortDesc: boolean[],\n  locale: string,\n  customSorters?: Record<string, DataTableCompareFunction<T>>\n): T[] {\n  if (sortBy === null || !sortBy.length) return items\n  const stringCollator = new Intl.Collator(locale, { sensitivity: 'accent', usage: 'sort' })\n\n  return items.sort((a, b) => {\n    for (let i = 0; i < sortBy.length; i++) {\n      const sortKey = sortBy[i]\n\n      let sortA = getObjectValueByPath(a, sortKey)\n      let sortB = getObjectValueByPath(b, sortKey)\n\n      if (sortDesc[i]) {\n        [sortA, sortB] = [sortB, sortA]\n      }\n\n      if (customSorters && customSorters[sortKey]) {\n        const customResult = customSorters[sortKey](sortA, sortB)\n\n        if (!customResult) continue\n\n        return customResult\n      }\n\n      // Check if both cannot be evaluated\n      if (sortA === null && sortB === null) {\n        continue\n      }\n\n      [sortA, sortB] = [sortA, sortB].map(s => (s || '').toString().toLocaleLowerCase())\n\n      if (sortA !== sortB) {\n        if (!isNaN(sortA) && !isNaN(sortB)) return Number(sortA) - Number(sortB)\n        return stringCollator.compare(sortA, sortB)\n      }\n    }\n\n    return 0\n  })\n}\n\nexport function defaultFilter (value: any, search: string | null, item: any) {\n  return value != null &&\n    search != null &&\n    typeof value !== 'boolean' &&\n    value.toString().toLocaleLowerCase().indexOf(search.toLocaleLowerCase()) !== -1\n}\n\nexport function searchItems<T extends any = any> (items: T[], search: string): T[] {\n  if (!search) return items\n  search = search.toString().toLowerCase()\n  if (search.trim() === '') return items\n\n  return items.filter(item => Object.keys(item).some(key => defaultFilter(getObjectValueByPath(item, key), search, item)))\n}\n\n/**\n * Returns:\n *  - 'normal' for old style slots - `<template slot=\"default\">`\n *  - 'scoped' for old style scoped slots (`<template slot=\"default\" slot-scope=\"data\">`) or bound v-slot (`#default=\"data\"`)\n *  - 'v-slot' for unbound v-slot (`#default`) - only if the third param is true, otherwise counts as scoped\n */\nexport function getSlotType<T extends boolean = false> (vm: Vue, name: string, split?: T): (T extends true ? 'v-slot' : never) | 'normal' | 'scoped' | void {\n  if (vm.$slots[name] && vm.$scopedSlots[name] && (vm.$scopedSlots[name] as any).name) {\n    return split ? 'v-slot' as any : 'scoped'\n  }\n  if (vm.$slots[name]) return 'normal'\n  if (vm.$scopedSlots[name]) return 'scoped'\n}\n\nexport function debounce (fn: Function, delay: number) {\n  let timeoutId = 0 as any\n  return (...args: any[]) => {\n    clearTimeout(timeoutId)\n    timeoutId = setTimeout(() => fn(...args), delay)\n  }\n}\n\nexport function getPrefixedScopedSlots (prefix: string, scopedSlots: any) {\n  return Object.keys(scopedSlots).filter(k => k.startsWith(prefix)).reduce((obj: any, k: string) => {\n    obj[k.replace(prefix, '')] = scopedSlots[k]\n    return obj\n  }, {})\n}\n\nexport function getSlot (vm: Vue, name = 'default', data?: object | (() => object), optional = false) {\n  if (vm.$scopedSlots[name]) {\n    return vm.$scopedSlots[name]!(data instanceof Function ? data() : data)\n  } else if (vm.$slots[name] && (!data || optional)) {\n    return vm.$slots[name]\n  }\n  return undefined\n}\n\nexport function clamp (value: number, min = 0, max = 1) {\n  return Math.max(min, Math.min(max, value))\n}\n\nexport function padEnd (str: string, length: number, char = '0') {\n  return str + char.repeat(Math.max(0, length - str.length))\n}\n\nexport function chunk (str: string, size = 1) {\n  const chunked: string[] = []\n  let index = 0\n  while (index < str.length) {\n    chunked.push(str.substr(index, size))\n    index += size\n  }\n  return chunked\n}\n\nexport function humanReadableFileSize (bytes: number, binary = false): string {\n  const base = binary ? 1024 : 1000\n  if (bytes < base) {\n    return `${bytes} B`\n  }\n\n  const prefix = binary ? ['Ki', 'Mi', 'Gi'] : ['k', 'M', 'G']\n  let unit = -1\n  while (Math.abs(bytes) >= base && unit < prefix.length - 1) {\n    bytes /= base\n    ++unit\n  }\n  return `${bytes.toFixed(1)} ${prefix[unit]}B`\n}\n\nexport function camelizeObjectKeys (obj: Record<string, any> | null | undefined) {\n  if (!obj) return {}\n\n  return Object.keys(obj).reduce((o: any, key: string) => {\n    o[camelize(key)] = obj[key]\n    return o\n  }, {})\n}\n\nexport function mergeDeep (\n  source: Dictionary<any> = {},\n  target: Dictionary<any> = {}\n) {\n  for (const key in target) {\n    const sourceProperty = source[key]\n    const targetProperty = target[key]\n\n    // Only continue deep merging if\n    // both properties are objects\n    if (\n      isObject(sourceProperty) &&\n      isObject(targetProperty)\n    ) {\n      source[key] = mergeDeep(sourceProperty, targetProperty)\n\n      continue\n    }\n\n    source[key] = targetProperty\n  }\n\n  return source\n}\n","import { ColorInt, XYZ } from '../colorUtils'\nimport { clamp } from '../../util/helpers'\n\n// For converting XYZ to sRGB\nconst srgbForwardMatrix = [\n  [3.2406, -1.5372, -0.4986],\n  [-0.9689, 1.8758, 0.0415],\n  [0.0557, -0.2040, 1.0570],\n]\n\n// Forward gamma adjust\nconst srgbForwardTransform = (C: number): number => (\n  C <= 0.0031308\n    ? C * 12.92\n    : 1.055 * C ** (1 / 2.4) - 0.055\n)\n\n// For converting sRGB to XYZ\nconst srgbReverseMatrix = [\n  [0.4124, 0.3576, 0.1805],\n  [0.2126, 0.7152, 0.0722],\n  [0.0193, 0.1192, 0.9505],\n]\n\n// Reverse gamma adjust\nconst srgbReverseTransform = (C: number): number => (\n  C <= 0.04045\n    ? C / 12.92\n    : ((C + 0.055) / 1.055) ** 2.4\n)\n\nexport function fromXYZ (xyz: XYZ): ColorInt {\n  const rgb = Array(3)\n  const transform = srgbForwardTransform\n  const matrix = srgbForwardMatrix\n\n  // Matrix transform, then gamma adjustment\n  for (let i = 0; i < 3; ++i) {\n    rgb[i] = Math.round(clamp(transform(\n      matrix[i][0] * xyz[0] +\n      matrix[i][1] * xyz[1] +\n      matrix[i][2] * xyz[2]\n    )) * 255)\n  }\n\n  // Rescale back to [0, 255]\n  return (rgb[0] << 16) + (rgb[1] << 8) + (rgb[2] << 0)\n}\n\nexport function toXYZ (rgb: ColorInt): XYZ {\n  const xyz: XYZ = [0, 0, 0]\n  const transform = srgbReverseTransform\n  const matrix = srgbReverseMatrix\n\n  // Rescale from [0, 255] to [0, 1] then adjust sRGB gamma to linear RGB\n  const r = transform((rgb >> 16 & 0xff) / 255)\n  const g = transform((rgb >> 8 & 0xff) / 255)\n  const b = transform((rgb >> 0 & 0xff) / 255)\n\n  // Matrix color space transform\n  for (let i = 0; i < 3; ++i) {\n    xyz[i] = matrix[i][0] * r + matrix[i][1] * g + matrix[i][2] * b\n  }\n\n  return xyz\n}\n","import { XYZ, LAB } from '../colorUtils'\n\nconst delta = 0.20689655172413793 // 6÷29\n\nconst cielabForwardTransform = (t: number): number => (\n  t > delta ** 3\n    ? Math.cbrt(t)\n    : (t / (3 * delta ** 2)) + 4 / 29\n)\n\nconst cielabReverseTransform = (t: number): number => (\n  t > delta\n    ? t ** 3\n    : (3 * delta ** 2) * (t - 4 / 29)\n)\n\nexport function fromXYZ (xyz: XYZ): LAB {\n  const transform = cielabForwardTransform\n  const transformedY = transform(xyz[1])\n\n  return [\n    116 * transformedY - 16,\n    500 * (transform(xyz[0] / 0.95047) - transformedY),\n    200 * (transformedY - transform(xyz[2] / 1.08883)),\n  ]\n}\n\nexport function toXYZ (lab: LAB): XYZ {\n  const transform = cielabReverseTransform\n  const Ln = (lab[0] + 16) / 116\n  return [\n    transform(Ln + lab[1] / 500) * 0.95047,\n    transform(Ln),\n    transform(Ln - lab[2] / 200) * 1.08883,\n  ]\n}\n","import { VNodeData } from 'vue'\n\n/**\n * Removes duplicate `@input` listeners when\n * using v-model with functional components\n *\n * @see https://github.com/vuetifyjs/vuetify/issues/4460\n */\nexport default function dedupeModelListeners (data: VNodeData): void {\n  if (data.model && data.on && data.on.input) {\n    if (Array.isArray(data.on.input)) {\n      const i = data.on.input.indexOf(data.model.callback)\n      if (i > -1) data.on.input.splice(i, 1)\n    } else {\n      delete data.on.input\n    }\n  }\n}\n","function createMessage (message: string, vm?: any, parent?: any): string | void {\n  if (parent) {\n    vm = {\n      _isVue: true,\n      $parent: parent,\n      $options: vm,\n    }\n  }\n\n  if (vm) {\n    // Only show each message once per instance\n    vm.$_alreadyWarned = vm.$_alreadyWarned || []\n    if (vm.$_alreadyWarned.includes(message)) return\n    vm.$_alreadyWarned.push(message)\n  }\n\n  return `[Vuetify] ${message}` + (\n    vm ? generateComponentTrace(vm) : ''\n  )\n}\n\nexport function consoleInfo (message: string, vm?: any, parent?: any): void {\n  const newMessage = createMessage(message, vm, parent)\n  newMessage != null && console.info(newMessage)\n}\n\nexport function consoleWarn (message: string, vm?: any, parent?: any): void {\n  const newMessage = createMessage(message, vm, parent)\n  newMessage != null && console.warn(newMessage)\n}\n\nexport function consoleError (message: string, vm?: any, parent?: any): void {\n  const newMessage = createMessage(message, vm, parent)\n  newMessage != null && console.error(newMessage)\n}\n\nexport function deprecate (original: string, replacement: string, vm?: any, parent?: any) {\n  consoleWarn(`[UPGRADE] '${original}' is deprecated, use '${replacement}' instead.`, vm, parent)\n}\nexport function breaking (original: string, replacement: string, vm?: any, parent?: any) {\n  consoleError(`[BREAKING] '${original}' has been removed, use '${replacement}' instead. For more information, see the upgrade guide https://github.com/vuetifyjs/vuetify/releases/tag/v2.0.0#user-content-upgrade-guide`, vm, parent)\n}\nexport function removed (original: string, vm?: any, parent?: any) {\n  consoleWarn(`[REMOVED] '${original}' has been removed. You can safely omit it.`, vm, parent)\n}\n\n/**\n * Shamelessly stolen from vuejs/vue/blob/dev/src/core/util/debug.js\n */\n\nconst classifyRE = /(?:^|[-_])(\\w)/g\nconst classify = (str: string) => str\n  .replace(classifyRE, c => c.toUpperCase())\n  .replace(/[-_]/g, '')\n\nfunction formatComponentName (vm: any, includeFile?: boolean): string {\n  if (vm.$root === vm) {\n    return '<Root>'\n  }\n  const options = typeof vm === 'function' && vm.cid != null\n    ? vm.options\n    : vm._isVue\n      ? vm.$options || vm.constructor.options\n      : vm || {}\n  let name = options.name || options._componentTag\n  const file = options.__file\n  if (!name && file) {\n    const match = file.match(/([^/\\\\]+)\\.vue$/)\n    name = match && match[1]\n  }\n\n  return (\n    (name ? `<${classify(name)}>` : `<Anonymous>`) +\n    (file && includeFile !== false ? ` at ${file}` : '')\n  )\n}\n\nfunction generateComponentTrace (vm: any): string {\n  if (vm._isVue && vm.$parent) {\n    const tree: any[] = []\n    let currentRecursiveSequence = 0\n    while (vm) {\n      if (tree.length > 0) {\n        const last: any = tree[tree.length - 1]\n        if (last.constructor === vm.constructor) {\n          currentRecursiveSequence++\n          vm = vm.$parent\n          continue\n        } else if (currentRecursiveSequence > 0) {\n          tree[tree.length - 1] = [last, currentRecursiveSequence]\n          currentRecursiveSequence = 0\n        }\n      }\n      tree.push(vm)\n      vm = vm.$parent\n    }\n    return '\\n\\nfound in\\n\\n' + tree\n      .map((vm, i) => `${\n        i === 0 ? '---> ' : ' '.repeat(5 + i * 2)\n      }${\n        Array.isArray(vm)\n          ? `${formatComponentName(vm[0])}... (${vm[1]} recursive calls)`\n          : formatComponentName(vm)\n      }`)\n      .join('\\n')\n  } else {\n    return `\\n\\n(found in ${formatComponentName(vm)})`\n  }\n}\n","/**\n * @copyright 2017 Alex Regan\n * @license MIT\n * @see https://github.com/alexsasharegan/vue-functional-data-merge\n */\n/* eslint-disable max-statements */\nimport { VNodeData } from 'vue'\nimport { camelize } from './helpers'\n\nconst pattern = {\n  styleList: /;(?![^(]*\\))/g,\n  styleProp: /:(.*)/,\n} as const\n\nfunction parseStyle (style: string) {\n  const styleMap: Dictionary<any> = {}\n\n  for (const s of style.split(pattern.styleList)) {\n    let [key, val] = s.split(pattern.styleProp)\n    key = key.trim()\n    if (!key) {\n      continue\n    }\n    // May be undefined if the `key: value` pair is incomplete.\n    if (typeof val === 'string') {\n      val = val.trim()\n    }\n    styleMap[camelize(key)] = val\n  }\n\n  return styleMap\n}\n\n/**\n * Intelligently merges data for createElement.\n * Merges arguments left to right, preferring the right argument.\n * Returns new VNodeData object.\n */\nexport default function mergeData (...vNodeData: VNodeData[]): VNodeData\nexport default function mergeData (): VNodeData {\n  const mergeTarget: VNodeData & Dictionary<any> = {}\n  let i: number = arguments.length\n  let prop: string\n  let event: string\n\n  // Allow for variadic argument length.\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'style':\n        case 'directives':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (!Array.isArray(mergeTarget[prop])) {\n            mergeTarget[prop] = []\n          }\n\n          if (prop === 'style') {\n            let style: any[]\n            if (Array.isArray(arguments[i].style)) {\n              style = arguments[i].style\n            } else {\n              style = [arguments[i].style]\n            }\n            for (let j = 0; j < style.length; j++) {\n              const s = style[j]\n              if (typeof s === 'string') {\n                style[j] = parseStyle(s)\n              }\n            }\n            arguments[i].style = style\n          }\n\n          // Repackaging in an array allows Vue runtime\n          // to merge class/style bindings regardless of type.\n          mergeTarget[prop] = mergeTarget[prop].concat(arguments[i][prop])\n          break\n        // Space delimited string concatenation strategy\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = ''\n          }\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' '\n          }\n          mergeTarget[prop] += arguments[i][prop].trim()\n          break\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n        case 'on':\n        case 'nativeOn':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {}\n          }\n          const listeners = mergeTarget[prop]!\n          for (event of Object.keys(arguments[i][prop] || {})) {\n            // Concat function to array of functions if callback present.\n            if (listeners[event]) {\n              // Insert current iteration data in beginning of merged array.\n              listeners[event] = Array<Function>().concat( // eslint-disable-line\n                listeners[event],\n                arguments[i][prop][event]\n              )\n            } else {\n              // Straight assign.\n              listeners[event] = arguments[i][prop][event]\n            }\n          }\n          break\n        // Object merge strategy\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {}\n          }\n          mergeTarget[prop] = { ...arguments[i][prop], ...mergeTarget[prop] }\n          break\n        // Reassignment strategy (no merge)\n        case 'slot':\n        case 'key':\n        case 'ref':\n        case 'tag':\n        case 'show':\n        case 'keepAlive':\n        default:\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop]\n          }\n      }\n    }\n  }\n\n  return mergeTarget\n}\n"],"sourceRoot":""}